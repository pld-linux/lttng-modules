diff --git a/Makefile b/Makefile
index eeffdfe..07d9d72 100644
--- a/Makefile
+++ b/Makefile
@@ -35,7 +35,8 @@ lttng-tracer-objs :=  lttng-events.o lttng-abi.o \
 			lttng-context-vtid.o lttng-context-ppid.o \
 			lttng-context-vppid.o lttng-calibrate.o \
 			lttng-context-hostname.o wrapper/random.o \
-			probes/lttng.o wrapper/trace-clock.o
+			probes/lttng.o wrapper/trace-clock.o \
+			wrapper/page_alloc.o
 
 obj-m += lttng-statedump.o
 lttng-statedump-objs := lttng-statedump-impl.o wrapper/irqdesc.o \
@@ -53,7 +54,8 @@ lttng-tracer-objs += $(shell \
 endif # CONFIG_PERF_EVENTS
 
 lttng-tracer-objs += $(shell \
-	if [ $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 15 -a $(SUBLEVEL) -ge 0 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 15 -a $(SUBLEVEL) -ge 0 \) ] ; then \
 		echo "lttng-tracepoint.o" ; fi;)
 
 obj-m += probes/
diff --git a/instrumentation/events/lttng-module/compaction.h b/instrumentation/events/lttng-module/compaction.h
index 3becac8..7914e23 100644
--- a/instrumentation/events/lttng-module/compaction.h
+++ b/instrumentation/events/lttng-module/compaction.h
@@ -9,6 +9,60 @@
 #include <linux/version.h>
 #include <trace/events/gfpflags.h>
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0)
+
+LTTNG_TRACEPOINT_EVENT_CLASS(mm_compaction_isolate_template,
+
+	TP_PROTO(unsigned long start_pfn,
+		unsigned long end_pfn,
+		unsigned long nr_scanned,
+		unsigned long nr_taken),
+
+	TP_ARGS(start_pfn, end_pfn, nr_scanned, nr_taken),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, start_pfn)
+		__field(unsigned long, end_pfn)
+		__field(unsigned long, nr_scanned)
+		__field(unsigned long, nr_taken)
+	),
+
+	TP_fast_assign(
+		tp_assign(start_pfn, start_pfn)
+		tp_assign(end_pfn, end_pfn)
+		tp_assign(nr_scanned, nr_scanned)
+		tp_assign(nr_taken, nr_taken)
+	),
+
+	TP_printk("range=(0x%lx ~ 0x%lx) nr_scanned=%lu nr_taken=%lu",
+		__entry->start_pfn,
+		__entry->end_pfn,
+		__entry->nr_scanned,
+		__entry->nr_taken)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(mm_compaction_isolate_template, mm_compaction_isolate_migratepages,
+
+	TP_PROTO(unsigned long start_pfn,
+		unsigned long end_pfn,
+		unsigned long nr_scanned,
+		unsigned long nr_taken),
+
+	TP_ARGS(start_pfn, end_pfn, nr_scanned, nr_taken)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(mm_compaction_isolate_template, mm_compaction_isolate_freepages,
+
+	TP_PROTO(unsigned long start_pfn,
+		unsigned long end_pfn,
+		unsigned long nr_scanned,
+		unsigned long nr_taken),
+
+	TP_ARGS(start_pfn, end_pfn, nr_scanned, nr_taken)
+)
+
+#else /* #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0) */
+
 LTTNG_TRACEPOINT_EVENT_CLASS(mm_compaction_isolate_template,
 
 	TP_PROTO(unsigned long nr_scanned,
@@ -46,6 +100,8 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(mm_compaction_isolate_template, mm_compaction_is
 	TP_ARGS(nr_scanned, nr_taken)
 )
 
+#endif /* #else #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0) */
+
 #if LTTNG_KERNEL_RANGE(3,12,30, 3,13,0) || \
 	LTTNG_KERNEL_RANGE(3,14,25, 3,15,0) || \
 	(LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0))
diff --git a/instrumentation/events/lttng-module/kmem.h b/instrumentation/events/lttng-module/kmem.h
index 203a19c..710c9fa 100644
--- a/instrumentation/events/lttng-module/kmem.h
+++ b/instrumentation/events/lttng-module/kmem.h
@@ -286,7 +286,93 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE_PRINT(mm_page, mm_page_pcpu_drain,
 		__entry->order, __entry->migratetype)
 )
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2)	\
+	|| LTTNG_KERNEL_RANGE(3,14,36, 3,15,0))
+
+LTTNG_TRACEPOINT_EVENT(mm_page_alloc_extfrag,
+
+	TP_PROTO(struct page *page,
+		int alloc_order, int fallback_order,
+		int alloc_migratetype, int fallback_migratetype),
+
+	TP_ARGS(page,
+		alloc_order, fallback_order,
+		alloc_migratetype, fallback_migratetype),
+
+	TP_STRUCT__entry(
+		__field_hex(	struct page *,	page			)
+		__field(	int,		alloc_order		)
+		__field(	int,		fallback_order		)
+		__field(	int,		alloc_migratetype	)
+		__field(	int,		fallback_migratetype	)
+		__field(	int,		change_ownership	)
+	),
+
+	TP_fast_assign(
+		tp_assign(page, page)
+		tp_assign(alloc_order, alloc_order)
+		tp_assign(fallback_order, fallback_order)
+		tp_assign(alloc_migratetype, alloc_migratetype)
+		tp_assign(fallback_migratetype, fallback_migratetype)
+		tp_assign(change_ownership,
+			(alloc_migratetype == get_pageblock_migratetype(page)))
+	),
+
+	TP_printk("page=%p pfn=%lu alloc_order=%d fallback_order=%d pageblock_order=%d alloc_migratetype=%d fallback_migratetype=%d fragmenting=%d change_ownership=%d",
+		__entry->page,
+		page_to_pfn(__entry->page),
+		__entry->alloc_order,
+		__entry->fallback_order,
+		pageblock_order,
+		__entry->alloc_migratetype,
+		__entry->fallback_migratetype,
+		__entry->fallback_order < pageblock_order,
+		__entry->change_ownership)
+)
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,30))
+
+LTTNG_TRACEPOINT_EVENT(mm_page_alloc_extfrag,
+
+	TP_PROTO(struct page *page,
+		int alloc_order, int fallback_order,
+		int alloc_migratetype, int fallback_migratetype, int new_migratetype),
+
+	TP_ARGS(page,
+		alloc_order, fallback_order,
+		alloc_migratetype, fallback_migratetype, new_migratetype),
+
+	TP_STRUCT__entry(
+		__field_hex(	struct page *,	page			)
+		__field(	int,		alloc_order		)
+		__field(	int,		fallback_order		)
+		__field(	int,		alloc_migratetype	)
+		__field(	int,		fallback_migratetype	)
+		__field(	int,		change_ownership	)
+	),
+
+	TP_fast_assign(
+		tp_assign(page, page)
+		tp_assign(alloc_order, alloc_order)
+		tp_assign(fallback_order, fallback_order)
+		tp_assign(alloc_migratetype, alloc_migratetype)
+		tp_assign(fallback_migratetype, fallback_migratetype)
+		tp_assign(change_ownership, (new_migratetype == alloc_migratetype))
+	),
+
+	TP_printk("page=%p pfn=%lu alloc_order=%d fallback_order=%d pageblock_order=%d alloc_migratetype=%d fallback_migratetype=%d fragmenting=%d change_ownership=%d",
+		__entry->page,
+		page_to_pfn(__entry->page),
+		__entry->alloc_order,
+		__entry->fallback_order,
+		pageblock_order,
+		__entry->alloc_migratetype,
+		__entry->fallback_migratetype,
+		__entry->fallback_order < pageblock_order,
+		__entry->change_ownership)
+)
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 
 LTTNG_TRACEPOINT_EVENT(mm_page_alloc_extfrag,
 
diff --git a/instrumentation/events/lttng-module/regmap.h b/instrumentation/events/lttng-module/regmap.h
index 87df6a6..e1a27e7 100644
--- a/instrumentation/events/lttng-module/regmap.h
+++ b/instrumentation/events/lttng-module/regmap.h
@@ -14,6 +14,50 @@ struct device;
 struct regmap;
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,4))
+/*
+ * Log register events
+ */
+LTTNG_TRACEPOINT_EVENT_CLASS(regmap_reg,
+
+	TP_PROTO(struct regmap *map, unsigned int reg,
+		 unsigned int val),
+
+	TP_ARGS(map, reg, val),
+
+	TP_STRUCT__entry(
+		__string(	name,		regmap_name(map))
+		__field(	unsigned int,	reg		)
+		__field(	unsigned int,	val		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, regmap_name(map))
+		tp_assign(reg, reg)
+		tp_assign(val, val)
+	),
+
+	TP_printk("%s reg=%x val=%x", __get_str(name),
+		  (unsigned int)__entry->reg,
+		  (unsigned int)__entry->val)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_write,
+
+	TP_PROTO(struct regmap *map, unsigned int reg,
+		 unsigned int val),
+
+	TP_ARGS(map, reg, val)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_read,
+
+	TP_PROTO(struct regmap *map, unsigned int reg,
+		 unsigned int val),
+
+	TP_ARGS(map, reg, val)
+)
+#else
 /*
  * Log register events
  */
@@ -47,7 +91,6 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_write,
 		 unsigned int val),
 
 	TP_ARGS(dev, reg, val)
-
 )
 
 LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_read,
@@ -56,20 +99,79 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_read,
 		 unsigned int val),
 
 	TP_ARGS(dev, reg, val)
-
 )
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,4))
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_read_cache,
+
+	TP_PROTO(struct regmap *map, unsigned int reg,
+		 unsigned int val),
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+	TP_ARGS(map, reg, val)
+)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_reg, regmap_reg_read_cache,
 
 	TP_PROTO(struct device *dev, unsigned int reg,
 		 unsigned int val),
 
 	TP_ARGS(dev, reg, val)
-
 )
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,4))
+LTTNG_TRACEPOINT_EVENT_CLASS(regmap_block,
+
+	TP_PROTO(struct regmap *map, unsigned int reg, int count),
+
+	TP_ARGS(map, reg, count),
+
+	TP_STRUCT__entry(
+		__string(	name,		regmap_name(map))
+		__field(	unsigned int,	reg		)
+		__field(	int,		count		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, regmap_name(map))
+		tp_assign(reg, reg)
+		tp_assign(count, count)
+	),
+
+	TP_printk("%s reg=%x count=%d", __get_str(name),
+		  (unsigned int)__entry->reg,
+		  (int)__entry->count)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_block, regmap_hw_read_start,
+
+	TP_PROTO(struct regmap *map, unsigned int reg, int count),
+
+	TP_ARGS(map, reg, count)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_block, regmap_hw_read_done,
+
+	TP_PROTO(struct regmap *map, unsigned int reg, int count),
+
+	TP_ARGS(map, reg, count)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_block, regmap_hw_write_start,
+
+	TP_PROTO(struct regmap *map, unsigned int reg, int count),
+
+	TP_ARGS(map, reg, count)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_block, regmap_hw_write_done,
+
+	TP_PROTO(struct regmap *map, unsigned int reg, int count),
+
+	TP_ARGS(map, reg, count)
+)
+#else
 LTTNG_TRACEPOINT_EVENT_CLASS(regmap_block,
 
 	TP_PROTO(struct device *dev, unsigned int reg, int count),
@@ -120,7 +222,32 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_block, regmap_hw_write_done,
 
 	TP_ARGS(dev, reg, count)
 )
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,4))
+LTTNG_TRACEPOINT_EVENT(regcache_sync,
+
+	TP_PROTO(struct regmap *map, const char *type,
+		 const char *status),
+
+	TP_ARGS(map, type, status),
+
+	TP_STRUCT__entry(
+		__string(       name,           regmap_name(map))
+		__string(	status,		status		)
+		__string(	type,		type		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, regmap_name(map))
+		tp_strcpy(status, status)
+		tp_strcpy(type, type)
+	),
+
+	TP_printk("%s type=%s status=%s", __get_str(name),
+		  __get_str(type), __get_str(status))
+)
+#else
 LTTNG_TRACEPOINT_EVENT(regcache_sync,
 
 	TP_PROTO(struct device *dev, const char *type,
@@ -143,8 +270,44 @@ LTTNG_TRACEPOINT_EVENT(regcache_sync,
 	TP_printk("%s type=%s status=%s", __get_str(name),
 		  __get_str(type), __get_str(status))
 )
+#endif
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,4))
+LTTNG_TRACEPOINT_EVENT_CLASS(regmap_bool,
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+	TP_PROTO(struct regmap *map, bool flag),
+
+	TP_ARGS(map, flag),
+
+	TP_STRUCT__entry(
+		__string(	name,		regmap_name(map))
+		__field(	int,		flag		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, regmap_name(map))
+		tp_assign(flag, flag)
+	),
+
+	TP_printk("%s flag=%d", __get_str(name),
+		  (int)__entry->flag)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_bool, regmap_cache_only,
+
+	TP_PROTO(struct regmap *map, bool flag),
+
+	TP_ARGS(map, flag)
+)
+
+LTTNG_TRACEPOINT_EVENT_INSTANCE(regmap_bool, regmap_cache_bypass,
+
+	TP_PROTO(struct regmap *map, bool flag),
+
+	TP_ARGS(map, flag)
+)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 LTTNG_TRACEPOINT_EVENT_CLASS(regmap_bool,
 
 	TP_PROTO(struct device *dev, bool flag),
diff --git a/instrumentation/events/lttng-module/writeback.h b/instrumentation/events/lttng-module/writeback.h
index a7657ed..79f84b7 100644
--- a/instrumentation/events/lttng-module/writeback.h
+++ b/instrumentation/events/lttng-module/writeback.h
@@ -12,6 +12,8 @@
 
 #ifndef _TRACE_WRITEBACK_DEF_
 #define _TRACE_WRITEBACK_DEF_
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
 static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 {
 	struct super_block *sb = inode->i_sb;
@@ -21,8 +23,26 @@ static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 
 	return sb->s_bdi;
 }
+#endif /* #if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)) */
+
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+#define show_inode_state(state)					\
+	__print_flags(state, "|",				\
+		{I_DIRTY_SYNC,		"I_DIRTY_SYNC"},	\
+		{I_DIRTY_DATASYNC,	"I_DIRTY_DATASYNC"},	\
+		{I_DIRTY_PAGES,		"I_DIRTY_PAGES"},	\
+		{I_NEW,			"I_NEW"},		\
+		{I_WILL_FREE,		"I_WILL_FREE"},		\
+		{I_FREEING,		"I_FREEING"},		\
+		{I_CLEAR,		"I_CLEAR"},		\
+		{I_SYNC,		"I_SYNC"},		\
+		{I_DIRTY_TIME,		"I_DIRTY_TIME"},	\
+		{I_DIRTY_TIME_EXPIRED,	"I_DIRTY_TIME_EXPIRED"}, \
+		{I_REFERENCED,		"I_REFERENCED"}		\
+	)
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0)) */
 #define show_inode_state(state)					\
 	__print_flags(state, "|",				\
 		{I_DIRTY_SYNC,		"I_DIRTY_SYNC"},	\
@@ -35,6 +55,7 @@ static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 		{I_SYNC,		"I_SYNC"},		\
 		{I_REFERENCED,		"I_REFERENCED"}		\
 	)
+#endif /* #else #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0)) */
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 #define WB_WORK_REASON							\
@@ -48,7 +69,91 @@ static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 		{WB_REASON_FORKER_THREAD,	"forker_thread"}
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+
+LTTNG_TRACEPOINT_EVENT(writeback_dirty_page,
+	TP_PROTO(struct page *page, struct address_space *mapping),
+	TP_ARGS(page, mapping),
+	TP_STRUCT__entry (
+		__array_text(char, name, 32)
+		__field(unsigned long, ino)
+		__field(pgoff_t, index)
+	),
+	TP_fast_assign(
+		tp_memcpy(name,
+			mapping ? dev_name(inode_to_bdi(mapping->host)->dev) : "(unknown)", 32)
+		tp_assign(ino, mapping ? mapping->host->i_ino : 0)
+		tp_assign(index, page->index)
+	),
+	TP_printk("bdi %s: ino=%lu index=%lu",
+		__entry->name,
+		__entry->ino,
+		__entry->index
+	)
+)
+
+LTTNG_TRACEPOINT_EVENT_CLASS(writeback_dirty_inode_template,
+	TP_PROTO(struct inode *inode, int flags),
+	TP_ARGS(inode, flags),
+	TP_STRUCT__entry (
+		__array_text(char, name, 32)
+		__field(unsigned long, ino)
+		__field(unsigned long, state)
+		__field(unsigned long, flags)
+	),
+	TP_fast_assign(
+		/* may be called for files on pseudo FSes w/ unregistered bdi */
+		tp_memcpy(name,
+			inode_to_bdi(inode)->dev ?
+				dev_name(inode_to_bdi(inode)->dev) : "(unknown)", 32)
+		tp_assign(ino, inode->i_ino)
+		tp_assign(state, inode->i_state)
+		tp_assign(flags, flags)
+	),
+	TP_printk("bdi %s: ino=%lu flags=%s",
+		__entry->name,
+		__entry->ino,
+		show_inode_state(__entry->flags)
+	)
+)
+#define LTTNG_TRACEPOINT_EVENT_WRITEBACK_DIRTY_INODE_TEMPLATE(name) \
+LTTNG_TRACEPOINT_EVENT_INSTANCE(writeback_dirty_inode_template, name, \
+	TP_PROTO(struct inode *inode, int flags), \
+	TP_ARGS(inode, flags))
+LTTNG_TRACEPOINT_EVENT_WRITEBACK_DIRTY_INODE_TEMPLATE(writeback_dirty_inode_start)
+LTTNG_TRACEPOINT_EVENT_WRITEBACK_DIRTY_INODE_TEMPLATE(writeback_dirty_inode)
+LTTNG_TRACEPOINT_EVENT_WRITEBACK_DIRTY_INODE_TEMPLATE(writeback_mark_inode_dirty)
+
+LTTNG_TRACEPOINT_EVENT_CLASS(writeback_write_inode_template,
+	TP_PROTO(struct inode *inode, struct writeback_control *wbc),
+	TP_ARGS(inode, wbc),
+	TP_STRUCT__entry (
+		__array_text(char, name, 32)
+		__field(unsigned long, ino)
+		__field(int, sync_mode)
+	),
+	TP_fast_assign(
+		tp_memcpy(name,
+			dev_name(inode_to_bdi(inode)->dev), 32)
+		tp_assign(ino, inode->i_ino)
+		tp_assign(sync_mode, wbc->sync_mode)
+	),
+	TP_printk("bdi %s: ino=%lu sync_mode=%d",
+		__entry->name,
+		__entry->ino,
+		__entry->sync_mode
+	)
+)
+
+#define LTTNG_TRACEPOINT_EVENT_WRITEBACK_WRITE_INODE(name) \
+LTTNG_TRACEPOINT_EVENT_INSTANCE(writeback_write_inode_template, name, \
+	TP_PROTO(struct inode *inode, struct writeback_control *wbc), \
+	TP_ARGS(inode, wbc))
+LTTNG_TRACEPOINT_EVENT_WRITEBACK_WRITE_INODE(writeback_write_inode_start)
+LTTNG_TRACEPOINT_EVENT_WRITEBACK_WRITE_INODE(writeback_write_inode)
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
+
 LTTNG_TRACEPOINT_EVENT(writeback_dirty_page,
 	TP_PROTO(struct page *page, struct address_space *mapping),
 	TP_ARGS(page, mapping),
@@ -126,8 +231,28 @@ LTTNG_TRACEPOINT_EVENT_INSTANCE(writeback_write_inode_template, name, \
 	TP_ARGS(inode, wbc))
 LTTNG_TRACEPOINT_EVENT_WRITEBACK_WRITE_INODE(writeback_write_inode_start)
 LTTNG_TRACEPOINT_EVENT_WRITEBACK_WRITE_INODE(writeback_write_inode)
+
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)) */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
+
+LTTNG_TRACEPOINT_EVENT_CLASS(writeback_work_class,
+	TP_PROTO(struct backing_dev_info *bdi, struct wb_writeback_work *work),
+	TP_ARGS(bdi, work),
+	TP_STRUCT__entry(
+		__array_text(char, name, 32)
+	),
+	TP_fast_assign(
+		tp_memcpy(name, bdi->dev ? dev_name(bdi->dev) :
+				"(unknown)", 32)
+	),
+	TP_printk("bdi %s",
+		  __entry->name
+	)
+)
+
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0)) */
+
 LTTNG_TRACEPOINT_EVENT_CLASS(writeback_work_class,
 	TP_PROTO(struct backing_dev_info *bdi, struct wb_writeback_work *work),
 	TP_ARGS(bdi, work),
@@ -142,6 +267,9 @@ LTTNG_TRACEPOINT_EVENT_CLASS(writeback_work_class,
 		  __entry->name
 	)
 )
+
+#endif /* #else #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0)) */
+
 #define LTTNG_TRACEPOINT_EVENT_WRITEBACK_WORK_INSTANCE(name) \
 LTTNG_TRACEPOINT_EVENT_INSTANCE(writeback_work_class, name, \
 	TP_PROTO(struct backing_dev_info *bdi, struct wb_writeback_work *work), \
diff --git a/lttng-events.c b/lttng-events.c
index 135c8c5..2820a0e 100644
--- a/lttng-events.c
+++ b/lttng-events.c
@@ -20,6 +20,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/*
+ * This page_alloc.h wrapper needs to be included before gfpflags.h because it
+ * overrides a function with a define.
+ */
+#include "wrapper/page_alloc.h"
+
 #include <linux/module.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
@@ -1271,7 +1277,9 @@ static int __init lttng_events_init(void)
 	ret = wrapper_lttng_fixup_sig(THIS_MODULE);
 	if (ret)
 		return ret;
-
+	ret = wrapper_get_pfnblock_flags_mask_init();
+	if (ret)
+		return ret;
 	ret = lttng_tracepoint_init();
 	if (ret)
 		return ret;
diff --git a/lttng-kernel-version.h b/lttng-kernel-version.h
index 8fad8b0..ec8cee0 100644
--- a/lttng-kernel-version.h
+++ b/lttng-kernel-version.h
@@ -24,7 +24,12 @@
  */
 
 #include <linux/version.h>
-#include <linux/vermagic.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+#include <generated/utsrelease.h>
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)) */
+#include <linux/utsrelease.h>
+#endif /* #else #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)) */
 
 /*
  * This macro checks if the kernel version is between the two specified
diff --git a/probes/Makefile b/probes/Makefile
index 8e4ceb7..ee91224 100644
--- a/probes/Makefile
+++ b/probes/Makefile
@@ -169,37 +169,43 @@ CFLAGS_lttng-probe-printk.o += -Wframe-larger-than=2200
 endif
 
 obj-m +=  $(shell \
-	if [ \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 6 \) \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 6 \) \
 		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -eq 5 -a $(SUBLEVEL) -ge 2 \) \
 		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -eq 4 -a $(SUBLEVEL) -ge 9 \) \
 		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -eq 0 -a $(SUBLEVEL) -ge 41 \) ] ; then \
 		echo "lttng-probe-random.o" ; fi;)
 
 obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 2 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 2 \) ] ; then \
 		echo "lttng-probe-rcu.o" ; fi;)
 
 ifneq ($(CONFIG_REGMAP),)
 obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 2 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 2 \) ] ; then \
 		echo "lttng-probe-regmap.o" ; fi;)
 endif
 
 ifneq ($(CONFIG_PM_RUNTIME),)
 obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 2 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 2 \) ] ; then \
 		echo "lttng-probe-rpm.o" ; fi;)
 endif
 
 ifneq ($(CONFIG_SUNRPC),)
 obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 4 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 4 \) ] ; then \
 		echo "lttng-probe-sunrpc.o" ; fi;)
 endif
 
 ifneq ($(CONFIG_VIDEO_V4L2),)
 obj-m += $(shell \
-	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 14 ] ; then \
+	if [ $(VERSION) -ge 4 \
+		-o \( $(VERSION) -eq 3 -a $(PATCHLEVEL) -ge 14 \) ] ; then \
 		echo "lttng-probe-v4l2.o" ; fi;)
 endif
 
diff --git a/probes/lttng-events.h b/probes/lttng-events.h
index 22cabba..0796b71 100644
--- a/probes/lttng-events.h
+++ b/probes/lttng-events.h
@@ -181,7 +181,39 @@ void trace_##_name(_proto);
 
 #undef LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP_NOARGS
 #define LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP_NOARGS(_template, _name, _map) \
-void trace_##_name(void *__data);
+void trace_##_name(void);
+
+ /*
+ * Stage 1.1 of the trace events.
+ *
+ * Create dummy trace prototypes for each event class, and for each used
+ * template. This will allow checking whether the prototypes from the
+ * class and the instance using the class actually match.
+ */
+
+#include "lttng-events-reset.h"        /* Reset all macros within TRACE_EVENT */
+
+#undef TP_PROTO
+#define TP_PROTO(args...) args
+
+#undef TP_ARGS
+#define TP_ARGS(args...) args
+
+#undef LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP
+#define LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP(_template, _name, _map, _proto, _args) \
+void __event_template_proto___##_template(_proto);
+
+#undef LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP_NOARGS
+#define LTTNG_TRACEPOINT_EVENT_INSTANCE_MAP_NOARGS(_template, _name, _map) \
+void __event_template_proto___##_template(void);
+
+#undef LTTNG_TRACEPOINT_EVENT_CLASS_CODE
+#define LTTNG_TRACEPOINT_EVENT_CLASS_CODE(_name, _proto, _args, _locvar, _code, _tstruct, _assign, _print) \
+void __event_template_proto___##_name(_proto);
+
+#undef LTTNG_TRACEPOINT_EVENT_CLASS_CODE_NOARGS
+#define LTTNG_TRACEPOINT_EVENT_CLASS_CODE_NOARGS(_name, _locvar, _code, _tstruct, _assign, _print) \
+void __event_template_proto___##_name(void);
 
 #include TRACE_INCLUDE(TRACE_INCLUDE_FILE)
 
diff --git a/probes/lttng-probe-kmem.c b/probes/lttng-probe-kmem.c
index c8252ec..0120241 100644
--- a/probes/lttng-probe-kmem.c
+++ b/probes/lttng-probe-kmem.c
@@ -21,6 +21,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/*
+ * This page_alloc.h wrapper needs to be included before gfpflags.h because it
+ * overrides a function with a define.
+ */
+#include "../wrapper/page_alloc.h"
 #include <linux/module.h>
 #include "../lttng-tracer.h"
 
diff --git a/wrapper/page_alloc.c b/wrapper/page_alloc.c
new file mode 100644
index 0000000..184ec71
--- /dev/null
+++ b/wrapper/page_alloc.c
@@ -0,0 +1,68 @@
+/*
+ * wrapper/page_alloc.c
+ *
+ * wrapper around get_pfnblock_flags_mask. Using KALLSYMS to get its address
+ * when available, else we need to have a kernel that exports this function to
+ * GPL modules.
+ *
+ * Copyright (C) 2015 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; only
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "../lttng-kernel-version.h"
+
+#if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2))
+
+#include <linux/kallsyms.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include "kallsyms.h"
+#include "page_alloc.h"
+
+static
+unsigned long (*get_pfnblock_flags_mask_sym)(struct page *page,
+		unsigned long pfn,
+		unsigned long end_bitidx,
+		unsigned long mask);
+
+unsigned long wrapper_get_pfnblock_flags_mask(struct page *page,
+		unsigned long pfn,
+		unsigned long end_bitidx,
+		unsigned long mask)
+{
+	WARN_ON_ONCE(!get_pfnblock_flags_mask_sym);
+	if (get_pfnblock_flags_mask_sym) {
+		return get_pfnblock_flags_mask_sym(page, pfn, end_bitidx, mask);
+	} else {
+		return -ENOSYS;
+	}
+}
+EXPORT_SYMBOL_GPL(wrapper_get_pfnblock_flags_mask);
+
+int wrapper_get_pfnblock_flags_mask_init(void)
+{
+	get_pfnblock_flags_mask_sym =
+		(void *) kallsyms_lookup_funcptr("get_pfnblock_flags_mask");
+	if (!get_pfnblock_flags_mask_sym)
+		return -1;
+	return 0;
+}
+
+#else /* #if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2)) */
+
+#include <linux/pageblock-flags.h>
+
+#endif /* #else #if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2)) */
diff --git a/wrapper/page_alloc.h b/wrapper/page_alloc.h
new file mode 100644
index 0000000..06e2ddc
--- /dev/null
+++ b/wrapper/page_alloc.h
@@ -0,0 +1,54 @@
+#ifndef _LTTNG_WRAPPER_PAGE_ALLOC_H
+#define _LTTNG_WRAPPER_PAGE_ALLOC_H
+
+/*
+ * wrapper/page_alloc.h
+ *
+ * wrapper around get_pfnblock_flags_mask. Using KALLSYMS to get its address
+ * when available, else we need to have a kernel that exports this function to
+ * GPL modules.
+ *
+ * Copyright (C) 2015 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; only
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "../lttng-kernel-version.h"
+
+/*
+ * We need to redefine get_pfnblock_flags_mask to our wrapper, because
+ * the get_pageblock_migratetype() macro uses it.
+ */
+#if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2))
+
+#define get_pfnblock_flags_mask		wrapper_get_pfnblock_flags_mask
+
+#include <linux/mm_types.h>
+
+int wrapper_get_pfnblock_flags_mask_init(void);
+
+#else /* #if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2)) */
+
+#include <linux/mm_types.h>
+
+static inline
+int wrapper_get_pfnblock_flags_mask_init(void)
+{
+	return 0;
+}
+
+#endif /* else #if defined(CONFIG_KALLSYMS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,2)) */
+
+#endif /* _LTTNG_WRAPPER_PAGE_ALLOC_H */
